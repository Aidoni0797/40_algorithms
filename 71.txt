Алгоритм PAGERANK

В качестве практического примера рассмотрим алгоритм PageRank, который изначально использовался Google для
ранжирования результатов поиска по пользовательскому запросу. Он генерирует число, которое количественно 
определяет релевантность результатов поиска по запросу пользователя. Алгоритм был разработан в Стэнфорде 
в конце 1990-х годов двумя аспирантами, ЛАрри Пейджем и Сергеем Брином, которые позже основали Google

Алгоритм PageRank был назван в честь Ларри Пейджа (Page), который создал его вместе с Сергеем Брином во время
учебы в Стэнфордском университете.

Прежде всего необходимо сформулировать задачу, для которой PageRank был изначально разработан.

Постановка задачи

Всякий раз, когда мы вводим запрос в поисковую систему в интернете, мы получаем большое количество результатов.
Чтобы сделать результаты полезными для конечного пользователя, необходимо отсортировать веб-страницы по ряду
критериев. Отображаемые результаты ранжируются согласно критериям, заданным базовым алгоритмом.

Реализация алгоритма PageRank

Главная составляющая алгоритма PageRank - поиск наилучшего способа измерения релевантности каждой страницы, 
возвращаемой в результатах запроса. Для вычисления числа от 0 до 1, которое количественно отражает релевентность
конкретной страницы, алгоритм учитывает два компонента информации:

- Информация, непосредственно относящаяся к пользовательскому запросу. Этот компонент оценивает в контексте
запроса, несколько релевантно содержимое веб-страницы. Содержание страницы напрямую зависит от автора страницы.

- Информация, которая не относится непосредственно к пользовательскому запросу. Данный компонент пытается
количественно оценить релевантность каждой веб-страницы в контексте ее ссылок, просмотров и соседних страниц.
Этот компонент трудно рассчитать, так как веб-страницы неоднородны и трудно разработать общие для всей сети 
критерии.

Чтобы реализовать алгоритм PageRank а Python, сначала импортируем необходимые библиотеки:

import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
%matplotlib inline

В демонстрационных целях мы будем анализировать только пять веб-страниц в сети. Назовем этот набор страниц 
yPages, и пусть они находится в сети с именем yWeb:

myWeb = nx.DiGraph()
myPages = range(1,5)

Соединим их случайным образом, чтобы смоделировать реальную сеть:

connections = [(1,3),(2,1),(2,3),(3,1),(3,2),(3,4),(4,5),(5,1),(5,4)]
myWeb.add_nodes_from(myPages)
myWeb.add_edges_from(connections)

Теперь давайте построим следующий график:

pos = nx.shell_layout(myWeb)
nx.draw(myWeb, pos, arrows=True, with_labels=True)
plt.show()

Это создаст визуальное представление нашей сети.

В алгоритма PageRank шаблоны веб-страницы содержатся в матрице, называемой матрицей переходов (transition matrix).
Существуют алгоритмы, которые постоянно обновляют матрицу переходов, фиксируя непрерывно меняющееся состояние
сети. Размер матрицы переходов равен nxn, где n - количество вершии. Числа в матрице обозначают вероятность
того, что далее посетитель перейдет на эту страницу по предыдущей ссылке.

На графике выше показана наша статическая сеть. Зададим функцию для создания матрицы переходов.

def createPageRank(aGraph):
	nodes_set = len(aGraph)
	M = nx.to_numpy_matrix(aGraph)
	outwards = np.squeeze(np.asarray(np.sum(M, axis=1)))
	prob_outwards = np.array(
	[1.0/count
		if count>0 else 0.0 for count in outwards])
	G = np.asarray(np.multiply(M.T, prob_outwards))
	p = np.ones(nodes_set)/float(nodes_set)
	if np.min(np.sum(G, axis=0)) < 1.0:
		print('WARN: G is substochastic')
	return G, p

Обратите внимание, что эта функция вернет G, которая и представляет матрицу переходов для нашего графика.

Давайте сгенерируем матрицу переходов

Обратите внимание, что матрица переходов имеет размерность 5х5. Каждый столбец соответствует вершине графа.
Например, столбец 2 описывает вторую вершину. Существует вероятность 0.5, что посетитель перейдет с вершины 2
на вершину 1 или на вершину 3. Обратите внимание, что диагональ матрицы переходов содержит 0, так как на нашем
графе нет ссылки от вершины к самой себе. В реальной сети такая ссылка вполне может быть.

Обратите внимание, что матрица переходов является разреженной матрицей. По мере увеличения числа вершин большинство
ее значений будет равно 0.
	(115 страница)