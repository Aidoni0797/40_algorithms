Интерполяционный поиск

Бинарный поиск основан на логике, согласно которой он сосредотачивается на средней части данных. Интерполяционный
поиск более сложен. Он использует целевое значение для оценки положения элемента в отсортированном массиве.
Давайте попробуем понять это на примере. Предположим, мы хотим найти слово в словаре английского языка,
например river. Мы будем использовать эту информацию для интерполяции и начнем поиск слов, начинающихся
с r. В обобщенном виде интерполяционный поиск может быть реализован следующим образом:

def IntPolsearch(list, x):
	idx0 = 0
	idxn = (len(list)-1)
	found = False
	while idx0 <= idxn and x >=list[idx0] and x<=list[idxn]:
	#Ищем срединную точку
		mid = idx0 + int(((float(idxn-idx0)/(list[idxn]-list[idx0]))*(x-list[idx0])))
	#Сравниваем значение в средней точке со значением поиска
		if list[mid] == x:
			found = True
			return found
		if list[mid] < x:
			idx0 = mid+1
	return found

Вывод выглядит следующим образом:

list = [12,33,11,99,22,55,90]
sorted_list = BubbleSort(list)
print(IntPolsearch(list, 12))
print(IntPolsearch(list, 91))

True
False

Производительность интерполяционного поиска
Если данные распределны неравномерно? производительность алгоритма интерполяционного поиска будет низкой.
Наихудшая производительность этого алгоритма - O(N), наилучшая - O(log(log N)), если данные достаточно однородны.
