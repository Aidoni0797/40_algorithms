Практическое применение

Инструменты эффективного и точного поиска в структуре данных на практике имеют решающее значение. В зависимости 
выбранного алгоритма поиска вам может потребоваться предварительная сортировка данных. Выбор подходящих
алгоритмов сортировки и поиска зависит от типа и размера данных, а также от характера задачи, которую
вы пытаетесь решить.

Используем изученные алгоритмы для решения следующей задачи: сопоставление обращения в иммиграционный 
департемент некой страны с архивными записями. Когда кто-то подает заявление на визу для въезда в страну,
система пытается соспоставить его с уже имеющейся информацией. Если найдено хотя бы одно совпадение, то
система вычисляет, сколько раз в прошлом этот человек получал одобрение или отказ на въезд. Если же соавпадение
не найдено, система классифицирует заявителя как нового и выдает ему новый идентификатор. Система должна
осуществить поиск в архиве, обнаружить и идентифицировать кандидата. Эта информация крайне важна, потому
что если человек ранее подавал заявку и она была отклонена, это может негативно повлиять на решение по
новому обращению. Аналогично, если заявка была одобрена в прошлом, это увеличивает шансы на получение визы.
Как правило, в архивной базе данных миллионы строк, и нам протребуется хорошо продуменное решение для достижения 
нужного результата.
Предположим, что архивная таблица в базе данных выглядит следующим образом.

В данной таблице первый столбец - Персональный идентификатор. Он присваевается каждому заявителю в архивной базе данных.
Если в ней содержится 30 миллионов уникальных заявителей, то мы получим 30 миллионов индивидуальных персональных
идентификаторов.

Персональный идентификатор 
Идентификатор заявления
Имя
Фамилия
Дата рождения
Решение
Дата принятия решения

1-45583-677862-Джон-Доу-2000/09/19-Одобрено-2018/08/07
2-54543-877653-Иксмен-Икс-1970/03/10-Отказано-2018/06/07
3-34332-344565-Агро-Вака-1973/02/15-Отказано-2018/05/05
4-45583-677864-Джон-Доу-2000/09/19-Одобрено-2018/03/02
5-22331-344553-Кэл-Сортс-1975/01/02-Одобрено-2018/04/15

Второй столбец - это Идентификатор заявления. Каждый такой идентификатор связан с уникальным заявлением
в системе. В прошлом человек мог подавать заявки несколько раз. Это означает, что в базе данных у нас
будет больше уникальных идентификаторов заявлений, чем персональных идентификаторов. Например, как видно
из таблицы у Джона Доу только один персональный идентификатор, но два идентификатора заявлений.

В таблице представлен лишь образец архивного набора данных. Предположим, что наша структура данных содержит
около одного миллиона строк с записями о заявителях за последние 10 лет. Новые кандидаты непрерывно добавляются со средней 
скоростью около двух претендентов в минуту. Для каждого кандидата нам необходимо выполнить следующие
действия:
- Выдать заявителю новый идентификатор заявления.
- Проверить архивную базу данных на наличие совпадений.
- Если совпадение найдено, использовать уже имеющийся личный идентификатор заявителя. Нам также необходимо
определить, сколько раз заявка была одобрена или отклонена.
- Если совпадений не найдено, мы выдаем этому человеку новый личный идентификатор.

Предположим, что к нам пришел новый заявитель со следующими учетными данными:
- Имя: Джон
- Фамилия: Доу
- Дата рождения: 2000-09-19

Как же нам разработать приолжение, способное выполнять эффективный и экономичный поиск?

Одна из стратегий поиска нового заявления в базе данных выглядит следующим образом:

- Отсортировать базу данных по Дате рождения.
- Каждый раз, когда прибывает кандидат, присваивать ему новый Идентификатор заявления.
- Отобрать все записи, соответствующие данной Дате рождения. Это перчисный поиск.
- В найденных записях выполнить вторичный поиск, используя Имя и Фамилию.
- Если совпадение найдено, использовать Персональный идентификатор в качестве ссылки на заявителя. Подсчитать
количество одобрений и отказов.
- Если совпадений не найдено, выдать заявителю новый Персональный идентификатор.

Давайте попробуем подобрать правильный алгоритм сортировки архивной базы данных. Мы можем смело исключить
сортировку пузырьком, так как объем данных огромен. Сортировка методом Шелла будет работать лучше, но только
в том случае, если наши списки частично упорядочены. Лучше всего для этой задачи подходит сортировка слиянием.

Когда прибывает новый человек, нам необходимо отыскать его в базе данных. Поскольку данные уже отсортированы,
можно использовать либо интерполяционный, либо бинарный поиск. Скорее всего, записи о кандидатах будут упорядочены
согласно Дате рождения, поэтому мы можем без опаски использовать бинарный поиск.

Сначала мы осуществим поиск на основе Даты рождения, что даст нам соответствующий набор заявителей. Далее нам
потребуется найти нужного человека в небольшой группе людей, у которых одна и та же дата рождения. Поскольку
мы успешно сократили данные до небольшого подмножества, мы можем использовать любой алгоритм поиска, включая
сортировку пузырьком. Обратите внимание, что в данном случае мы немного упростили проблему вторичного поиска. Затем
нам нужно подсчитать общее количество одобрений и отказов путем агрегирования результатов поиска, если найдено
более одного совпадения.

На практике мы должны дополнительно использовать алгоритм нечеткого поиска, так как имя и фамилия могут быть 
записаны немного по-разному. Для этого нам может потребоваться какой-либо алгоритм определения сходства
(когда точки данных, сходство которых превышает определенный порог, считаются одинаковыми).