Сортировка Шелла

Алгоритм сортировки пузырьком сравнивает значения соседних элементов и меняет их местами, если они не
стоят в нужном порядке. Если список частично отсортирован, мы получаем приемлемую производительность:
сортировка завершается, как только в цикле преклращается обмен значениями.

В случае с полностью неотсорированным списком размера N алгоритм должен совершить N-1 полных проходов.

Дональд Шелл предложил свой алгоритм сортировки, поставив под сомнение необходимость выбора соседних элементов
для сравнения и обмена. Алгоритм получил название сортировки Шелла. (Shell sort).

Попробуем разобраться в этой концепции.

На первом проходе мы используем элементы, расположенные с фиксированным промежутком (вместо ближайших соседей).
В итоге получаем подсписок, состоящий из пар элементов данных. Процесс показан на диаграмме. На втором проходе 
алгоритм сортирует подписки, содержащие по четыре элемента данных. В последующих проходах количество элементов
в каждом подписке увеличивается, а количество самих подписков уменьшается. Когда остается только один подсписок,
содержащий все элементы данных, сортировка завершена.

На языке Python код для реализации алгоритма сортировки Шелла вяглядит так:

def ShellSort(list):
	distance = len(list) //2
	while distanc > 0:
		for i in range(distance, len(list)):
			temp = input_list[i]
			j = i
#Сортировка подписка для текущего значения дистанции
			while j >= distance and list[j-distance] > temp:
				list[j] = list[j-distance]
				j = j-distance
			list[j] = temp
#Уменьшаем расстояние до следующего элемента
		distance = distance //2
	return list

Представленный выше код можно использовать для сортировки списка следующим образом.

list = [26,17,20,11,23,21,13,18,24,14,12,22,16,15,19,25]

shellSort(list)
print(list)

[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]

Обратите внимание, что вызов функции ShellSort привел к сортировке исходного входного массива.

Анализ производительности сортировки Шелла.

Сортировка Шелла не предназначена для больших данных. Он используется для наборов данных среднего размера.
Грубо говоря, алгоритм даст достаточно хорошую производительность при работе со списком, содержащим до 6000
элементов. Если данные частично упорядочены, производительность будет выше. В идеале список полностью 
отсортирован, тогда для проверки порядка потребуется только один проход через N элементов, что обеспечит
наилучшую приозводительность О(N).

Сортировка выбором

Как мы выяснили, сортировка пузырьком является одним из простейших алгоритмов сортировки. Сортировка выбором
(selection sort) - это его улучшенная версия. С ее помощью мы стараемся минимизировать общее количество обменов значений
переменных. За каждый проход выполняется один обмен (сравните с N-1 в случае сортировки пузырьком). Вместо
того чтобы перемещать наибольшее значение маленькими шагами, мы ищем его на каждой итерации и ставим в конец
списка. Это значит, что в результате первого прохода наибольшее значение окажется справка, а в результате
второго прохода к нему переместится следующее по величине значение. По мере выполнения алгоритма последующие
элементы будут перемещаться в нужное место согласно их значению. Последний элемент будет перемещен после (N-1)го
прохода. Таким образом, сортировка выбором требует N-1 проходов для сортировки N элементов.

70-15-25-19-34-44

Проход 1 - 70 - наибольшее значение, перемещается вправо
Проход 2 - 44 - наибольшее значение, перемещается вправо
Проход 3 - 34 - наибольшее значение, перемещается вправо
Проход 4 - 25 - в нужной позиции
Проход 5 - 19 - наибольшее значение, перемещается вправо

Результат - 15 - 19 - 25 - 34 - 44 - 70

Реализация сортировки выбором на Python:

def SelectionSort(list):
	for fill_slot in range(len(list)-1,0,-1):
		max_index = 0
		for location in range(1,fill_slot+1):
			if list[location]>list[max_index]:
				max_index = location
		list[fill_slot],list[max_index] = list[max_index], list[fill_slot]

Когда алгоритм сортировки выбором выполнится, результат бдет следующим

list = [70,15,25,19,34,44]
SelectionSort(list)
print(list)
[15,19,25,34,44,70]

На выходе мы получаем отсортированный список.

Анализ производительности сортировки выбором

Наихдшая производительность алгоритма сортировки выбором - O(n*n), аналогично сортировке пузырьком. Поэтому его
не следует использовать для обработки больших наборов данных. Тем не менее сортировка выбором - это более
продуманный алгоритм, чем сортировка пузырьком, и его средняя производительность лучше из-за сокращения
числа обменов значений.

Выбор алгоритма сортировки

Выбор правильного алгоритма сортировки зависит как от размера, так и от состояния имеющихся входных данных.
Для небольших отсортированных списков использование продвинутого алгоритма приведет к ненужному усложнению
кода при незначительном приросте производительности. Например, не следует использовать сортировку слиянием 
для неболших наборов данных. Сортировка пузырьком будет намного проще как для понимания, так для и реализации.
Если данные частично отсортированы, мы можем воспользоваться этим преимуществом и применить сортировку вставкой.
Для больших наборов данных лучше всего использовать алгоритм сортировки слиянием.